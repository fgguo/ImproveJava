### 编程基础
#### 数据类型和变量
对Java语言而言，有如下基本数据类型。
- 整数类型：有4种整型byte/short/int/long，分别有不同的取值范围；
- 小数类型：有两种类型float/double，有不同的取值范围和精度；
- 字符类型：char，表示单个字符；
- 真假类型：boolean，表示真假

变量就是给数据起名字，方便找不同的数据，它的值可以变，但含义不应变。通过声明变量，每个变量赋予一个数据类型和一个有意义的名字，我们就告诉了计算机要操作的数据。

#### 数组类型
数组长度虽然可以动态确定，但定了之后就不可以变。数组有一个length属性，但只能读，不能改。还有一个小细节，不能在给定初始值的同时给定长度.
如：int [ ] arr = new int[3]{1,2,3}是不允许的。

数组类型和基本类型是有明显不同的，一个基本类型变量，内存中只会有一块对应的内存空间。但数组有两块：一块用于存储数组内容本身，另一块用于存储内容的位置。
用一个例子来说明，有一个int变量a，以及一个int数组变量arr，其代码、变量对应的内存地址和内存内容如下所示：
![](img_1.png)
基本类型a的内存地址是1000，这个位置存储的就是它的值100。数组类型arr的内存地址是2000，这个位置存储的值是一个位置3000,3000开始的位置存储的才是实际的数据“1, 2, 3”。

##### 为什么数组要用两块空间？
假设arrA初始的长度是3, arrB的长度是4，后来将arrB的值赋给了arrA。如果arrA对应的内存空间是直接存储的数组内容，那么它将没有足够的空间去容纳arrB的所有元素。用两块空间存储就简单得多，arrA存储的值就变成了和arrB的一样，存储的都是数组内容{4,5,6,7}的地址，此后访问arrA就和arrB是一样的了，而arrA {1,2,3}的内存空间由于不再被引用会进行垃圾回收，


给数组变量赋值和给数组中元素赋值是两回事，给数组中元素赋值是改变数组内容，而给数组变量赋值则会让变量指向一个不同的位置。上面我们说数组的长度是不可以变的，不可变指的是数组的内容空间，一经分配，长度就不能再变了，但可以改变数组变量的值，让它指向一个长度不同的空间，就像上例中arrA后来指向了arrB一样。给变量赋值就是将变量对应的内存空间设置为一个明确的值，有了值之后，变量可以被加载到CPU并使用。

#### 条件执行
- if的陷阱：初学者有时会忘记在if后面的代码块中加花括号，有时希望执行多条语句而没有花括号，结果只会执行第一条语句，建议所有if后面都加花括号。
- if/else if/else陷阱：需要注意的是，在if/else if/else中，判断的顺序是很重要的，后面的判断只有在前面的条件为false的时候才会执行。
- switch也比较简单，根据表达式的值执行不同的分支，具体来说，根据表达式的值找匹配的case，找到后执行后面的代码，碰到break时结束，如果没有找到匹配的值则执行default后的语句。表达式值的数据类型只能是byte、short、int、char、枚举和String（Java 7以后）。break是指跳出switch语句，执行switch后面的语句。每条case语句后面都应该跟break语句，否则会继续执行后面case中的代码直到碰到break语句或switch结束。

条件执行总体上是比较简单的：单一条件满足时，执行某操作使用if；根据一个条件是否满足执行不同分支使用if/else；表达复杂的条件使用if/else if/else；条件赋值使用三元运算符，根据某一个表达式的值不同执行不同的分支使用switch。

条件执行的语法是比较自然和容易理解的，需要注意的是其中的一些语法细节和陷阱。它执行的本质依赖于**条件跳转、无条件跳转和跳转表**.

#### 循环
在Java中，循环有4种形式，分别是while、do/while、for和foreach：
- while和if的语法很像，只是把if换成了while，它表达的含义也非常简单，只要条件语句为真，就一直执行后面的代码，为假就停止不做了。
- 如果不管条件语句是什么，代码块都会至少执行一次，则可以使用do/while循环。先执行代码块，然后再判断条件语句，如果成立，则继续循环，否则退出循环。
- for后面的括号中有两个分号；，分隔了三条语句。除了第二句循环条件必须返回一个boolean类型外，其他语句没有什么要求，但通常情况下第一条语句用于初始化，尤其是循环的索引变量，第三条语句修改循环变量，一般是步进，即递增或递减索引变量，循环体是在循环中执行的语句。for循环执行的流程如下：1）执行初始化指令；2）检查循环条件是否为true，如果为false，则跳转到第6步；3）循环条件为真，执行循环体；4）执行步进操作；5）步进操作执行完后，跳转到第2步，即继续检查循环条件；6）for循环后面的语句。
- 在for中，每条语句都是可以为空的，也就是说：for(;;)是有效的，这是个死循环，一直在空转，和while(true){}的效果是一样的。可以省略某些语句，但分号；不能省
- foreach不是一个关键字，它使用冒号：，冒号前面是循环中的每个元素，包括数据类型和变量名称，冒号后面是要遍历的数组或集合，每次循环冒号前的元素都会自动更新。对于不需要使用索引变量，只是简单遍历的情况，foreach语法上更为简洁。
- 和if一样，循环内部也是靠条件转移和无条件转移指令实现的。在if中，跳转只会往后面跳，而for会往前面跳，第6行就是无条件跳转指令，跳转到了前面的第3行。break/continue语句也都会转换为跳转指令。
#### 函数
函数的主要组成部分有以下几种。
- 1）函数名字：名字是不可或缺的，表示函数的功能。
- 2）参数：参数有0个到多个，每个参数由参数的数据类型和参数名字组成。
- 3）操作：函数的具体操作代码。
- 4）返回值：函数可以没有返回值，如果没有返回值则类型写成void，如果有则在函数代码中必须使用return语句返回一个值，这个值的类型需要和声明的返回值类型一致。
- 5）修饰符：Java中函数有很多修饰符，分别表示不同的目的。

Java中运行一个程序的时候，需要指定一个定义了main函数的类，Java会寻找main函数，并从main函数开始执行。不管main函数定义在哪里，Java函数都会先找到它，然后从它的第一行开始执行

调用函数如果没有参数要传递，也要加括号()，如print3Lines()。
传递的参数不一定是个变量，可以是常量，也可以是某个运算表达式，可以是某个函数的返回结果。

可变长度参数的语法是在数据类型后面加三个点“... ”，在函数内，可变长度参数可以看作是数组。可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度的参数。

函数返回值类型为void也可以使用return，即“return; ”，不用带值，含义是返回调用方，只是没有返回值而已。函数的返回值最多只能有一个，那如果实际情况需要多个返回值呢？比如，计算一个整数数组中的最大的前三个数，需要返回三个结果。这个可以用数组作为返回值，在函数内创建一个包含三个元素的数组，然后将前三个结果赋给对应的数组元素。如果实际情况需要的返回值是一种复合结果呢？比如，查找一个字符数组中所有重复出现的字符以及重复出现的次数。这个可以用对象作为返回值。

##### 函数调用的基本原理
函数调用主要是通过栈来存储相关的数据，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单认为是通过一个专门的返回值存储器存储的。具体书1.7节。

### 类的基础
#### 类的基本概念
##### 函数容器
static表示类方法，也叫静态方法，与类方法相对的是实例方法。实例方法没有static修饰符，必须通过实例或者对象调用，而类方法可以直接通过类名进行调用，不需要创建实例。public表示这些函数是公开的，可以在任何地方被外部调用。与public相对的是private。如果是private，则表示私有，这个函数只能在同一个类内被别的函数调用，而不能被外部的类调用。

这里将类看作函数的容器，更多的是从语言实现的角度看，从概念的角度看，Math和Arrays也可以看作自定义数据类型，分别表示数学和数组类型，其中的public static函数可以看作类型能进行的操作。

##### 自定义数据类型
可以**将类看作自定义数据类型**，所谓自定义数据类型就是除了8种基本类型以外的其他类型，用于表示和处理基本类型以外的其他数据。

一个数据类型就主要由4部分组成：
- 类型本身具有的属性，通过类变量体现。表示类变量的时候，static修饰符是必需的，但public和final都不是必需的。
- 类型本身可以进行的操作，通过类方法体现。
- 类型实例具有的属性，通过实例变量体现。
- 类型实例可以进行的操作，通过实例方法体现。所谓实例，字面意思就是一个实际的例子。实例变量表示具体的实例所具有的属性，实例方法表示具体的实例可以进行的操作。

**在实例方法中，有一个隐含的参数，这个参数就是当前操作的实例自己(this)**，直接操作实例变量，实际也需要通过参数进行。实例方法和类方法的更多区别如下所示:
- 类方法只能访问类变量，不能访问实例变量，可以调用其他的类方法，不能调用实例方法。
- 实例方法既能访问实例变量，也能访问类变量，既可以调用实例方法，也可以调用类方法。
```
Point p = new Point();
```
上面这个语句包含了Point类型的变量声明和赋值，可以看成Point p和p = new Point()两部分：
- Point p声明了一个变量，这个变量叫p,是Point类型的，这个变量和数组变量是类似的：都有两块内存，一块存放实际内容，一块存放实际内容的地址。**声明变量本身只会分配存放位置的内存空间，这块空间还没有指向任何实际内容**。因为这种变量和数组变量本身不存储数据，而只是存储实际内容的位置，它们也都称为**引用类型**的变量。 
- p = new Point()创建了一个实例或对象，然后赋值给了Point类型的变量p，它至少做了两件事：1）分配内存，以存储新对象的数据，对象数据包括这个对象的属性。2）给实例变量设置默认值，int类型默认值为0。与方法内定义的局部变量不同，在创建对象的时候，所有的实例变量都会分配一个默认值，这与创建数组的时候是类似的，数值类型变量的默认值是0, boolean是false, char是“\u0000”，引用类型变量都是null。null是一个特殊的值，表示不指向任何对象。这些默认值可以修改。
- 对实例变量和实例方法的访问都通过对象进行，通过对象来访问和操作其内部的数据是一种基本的面向对象思维。一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作。这也是为了减少误操作，直接访问变量没有办法进行参数检查和控制，而通过方法修改，可以在方法中进行检查。
##### 变量默认值
- 实例变量都有一个默认值，如果希望修改这个默认值，可以在定义变量的同时就赋值，或者将代码放入初始化代码块中，代码块用{}包围。比如：
```
    int x = 1;
    int y;
    {
        y = 2;        
    }
```

x的默认值设为了1, y的默认值设为了2。在新建一个对象的时候，会先调用这个初始化，然后才会执行构造方法中的代码
- 静态变量可以如下初始化：
```
    static int STATIC_ONE = 1;
    static int STATIC_TWO;
    static{
        STATIC_TWO = 2;
    }
```
STATIC_TWO=2；语句外面包了一个static {}，这叫静态初始化代码块。**静态初始化代码块在类加载的时候执行，这是在任何对象创建之前，且只执行一次**。

##### 构造方法
有一个更简单的方式对实例变量赋初值，就是构造方法：
```
    public Point(){
        this(0,0);
    }
    
    public Point(int x, int y){
        this.x = x;
        this.y = y;
    }
```
这两个就是构造方法，构造方法可以有多个。不同于一般方法，构造方法有一些特殊的地方：
- 1）名称是固定的，与类名相同
- 2）没有返回值，也不能有返回值。构造方法隐含的返回值就是实例本身。
- 3）与普通方法一样，构造方法也可以重载。第一个构造方法，this(0,0)的意思是调用第二个构造方法，并传递参数“0,0”，我们前面解释说this表示当前实例，可以通过this访问实例变量，这是**this的第二个用法，用于在构造方法中调用其他构造方法。这个this调用必须放在第一行**，这个规定也是为了避免误操作。构造方法是用于初始化对象的，如果要调用别的构造方法，先调别的，然后根据情况自己再做调整，而如果自己先初始化了一部分，再调别的，自己的修改可能就被覆盖了。

关于构造方法，下面讨论两个细节概念：一个是默认构造方法；另一个是私有构造方法。
- 每个类都至少要有一个构造方法，在通过new创建对象的过程中会被调用。但构造方法如果没什么操作要做，可以省略。Java编译器会自动生成一个默认构造方法，也没有具体操作。但**一旦定义了构造方法，Java就不会再自动生成默认的**。
- 构造方法可以是私有方法，即修饰符可以为private，为什么需要私有构造方法呢？大致可能有这么几种场景：1）不能创建类的实例，类只能被静态访问，如Math和Arrays类，它们的构造方法就是私有的。2）能创建类的实例，但只能被类的静态方法调用。有一种常见的场景：类的对象有但是只能有一个，即单例（单个实例）。在这种场景中，对象是通过静态方法获取的，而静态方法调用私有构造方法创建一个对象，如果对象已经创建过了，就重用这个对象。3）只是用来被其他多个构造方法调用，用于减少重复代码。

##### 类和对象的声明周期
当第一次通过new创建一个类的对象时，或者直接通过类名访问类变量和类方法时，Java会将类加载进内存，为这个类分配一块空间，这个空间会包括类的定义、它的变量和方法信息，同时还有类的静态变量，并对静态变量赋初始值。

类加载进内存后，一般不会释放，直到程序结束。一般情况下，类只会加载一次，所以静态变量在内存中只有一份。当通过new创建一个对象的时候，对象产生，在内存中，会存储这个对象的实例变量值，每做new操作一次，就会产生一个对象，就会有一份独立的实例变量。每个对象除了保存实例变量的值外，可以理解为还保存着对应类型即类的地址，这样，通过对象能知道它的类，访问到类的变量和方法代码。

对象的释放是被Java用垃圾回收机制管理的，大部分情况下，我们不用太操心，当对象不再被使用的时候会被自动释放。具体来说，对象和数组一样，有两块内存，保存地址的部分分配在栈中，而保存实际内容的部分分配在堆中。栈中的内存是自动管理的，函数调用入栈就会分配，而出栈就会释放。 堆中的内存是被垃圾回收机制管理的，当没有活跃变量指向对象的时候，对应的堆空间就可能被释放，具体释放时间是Java虚拟机自己决定的。活跃变量就是已加载的类的类变量，以及栈中所有的变量。

##### 本节提到的关键字汇总
- 1）public：可以修饰类、类方法、类变量、实例变量、实例方法、构造方法，表示可被外部访问。
- 2）private：可以修饰类、类方法、类变量、实例变量、实例方法、构造方法，表示不可以被外部访问，只能在类内部被使用。
- 3）static：修饰类变量和类方法，它也可以修饰内部类 。
- 4）this：表示当前实例，可以用于调用其他构造方法，访问实例变量，访问实例方法。
- 5）final：修饰类变量、实例变量，表示只能被赋值一次，也可以修饰实例方法和局部变量

#### 类的组合
看书，3.2jie，尤其是那几个类的例子。

将现实概念映射为类以及类组合的这个过程大概就是，想想现实问题有哪些概念，这些概念有哪些属性、哪些行为，概念之间有什么关系，然后定义类、定义属性、定义方法、定义类之间的关系。概念的属性和行为可能是非常多的，但定义的类只需要包括那些与现实问题相关的就行了。

类之间的组合关系在Java中实现的都是引用，但在逻辑关系上，有两种明显不同的关系，一种是包含，另一种是单纯引用。比如，在订单类Order中，Order与User的关系就是单纯引用，User是独立存在的；而Order与OrderItem的关系就是包含，OrderItem总是从属于某一个Order。

#### 代码的组织机制
##### 包的概念
使用任何语言进行编程都有一个相同的问题，就是命名冲突。程序一般不全是一个人写的，会调用系统提供的代码、第三方库中的代码、项目中其他人写的代码等，不同的人就不同的目的可能定义同样的类名/接口名，Java中解决这个问题的主要方法就是包。

包是一个比较容易理解的概念，类似于计算机中的文件夹，正如我们在计算机中管理文件，文件放在文件夹中一样，类和接口放在包中，为便于组织，文件夹一般是一个层次结构，包也类似。包有包名，这个名称以点号（.）分隔表示层次结构。比如，常用的String类就位于包java.lang下，其中java是上层包名，lang是下层包名。**带完整包名的类名称为其完全限定名**。

包的声明、使用和包范围可见性：
- 定义类的时候，应该先使用关键字package声明其包名，包声明语句应该位于源代码的最前面，前面不能有注释外的其他语句。
- 为避免命名冲突，Java中命名包名的一个惯例是使用域名作为前缀，因为域名是唯一的，一般按照域名的反序来定义包名，比如，域名是apache.org，包名就以org.apache开头。没有域名的也没关系，使用一个其他代码不太会用的包名即可，比如shuo. laoma。如果代码需要公开给其他人用，最好有一个域名以确保唯一性，如果只是内部使用，则确保内部没有其他代码使用该包名即可。
- 同一个包下的类之间互相引用是不需要包名的，可以直接使用。但如果类不在同一个包内，则必须要知道其所在的包。使用有两种方式：一种是通过类的完全限定名；另外一种是将用到的类引入当前类，引入的关键字是import,import需要放在package定义之后。只有一个例外，java.lang包下的类可以直接使用，不需要引入，也不需要使用完全限定名，比如String类、System类，其他包内的类则不行。
- 有一种特殊类型的导入，称为静态导入，它有一个static关键字，可以直接导入类的公开静态方法和成员，比如
```
    import java.util.Arrays;
    import static java.util.Array.*; //导入Arrays中的所有静态方法
    import static java.lang.System.out; //导入静态变量out    
```
静态导入不应过度使用，否则难以区分访问的是哪个类的代码。

- 同一个包指的是同一个直接包，子包下的类并不能访问。比如，类shuo.laoma.Hello和shuo.laoma.inner.Test，其所在的包shuo.laoma和shuo.laoma.inner是两个完全独立的包，并没有逻辑上的联系，Hello类和Test类不能互相访问对方的包可见性方法和属性。

- 可以不写修饰符。如果什么修饰符都不写，它的可见性范围就是同一个包内，同一个包内的其他类可以访问，而其他包内的类则不可以访问。
- 除了public和private修饰符，还有一个与继承有关的修饰符protected。protected可见性包括包可见性，也就是说，声明为protected不仅表明子类可以访问，还表明同一个包内的其他类可以访问，即使这些类不是子类也可以。
- 总结来说，可见性范围从小到大是：private < 默认(包) < protected < public。

### 类的继承
计算机程序经常使用类之间的继承关系来表示对象之间的分类关系。在继承关系中，有父类和子类，比如动物类Animal和狗类Dog, Animal是父类，Dog是子类。父类也叫基类，子类也叫派生类。父类、子类是相对的，一个类B可能是类A的子类，但又是类C的父类。之所以叫继承，是因为子类继承了父类的属性和行为，父类有的属性和行为子类都有。但子类可以增加子类特有的属性和行为，某些父类有的行为，子类的实现方式可能与父类也不完全一样。使用继承一方面可以复用代码，公共的属性和行为可以放到父类中，而子类只需要关注子类特有的就可以了；另一方面，不同子类的对象可以更为方便地被统一处理。
#### 基本概念
- 在Java中，即使没有声明父类，也有一个隐含的父类，这个父类叫Object。Object没有定义属性，但定义了一些方法
- 所谓重写，就是定义和父类一样的方法，并重新实现。@Override表示重写
- 1）Java使用extends关键字表示继承关系，一个类最多只能有一个父类；2）子类不能直接访问父类的私有属性和方法。3）除了私有的外，子类继承了父类的其他属性和方法。
- new的过程中，父类的构造方法也会执行，且会优先于子类执行。
- super用于指代父类，可用于调用父类构造方法，访问父类方法和变量：1）super(color)表示调用父类的带color参数的构造方法。调用父类构造方法时，super必须放在第一行。2）super.getColor()表示调用父类的getColor方法，当然不写super.也是可以的，因为这个方法子类没有同名的，没有歧义，当有歧义的时候，通过super．可以明确表示调用父类的方法。3）super同样可以引用父类非私有的变量。
- 子类对象赋值给父类引用变量，这叫向上转型，转型就是转换类型，向上转型就是转换为父类类型。
- Shape shape定义的变量可以引用任何Shape子类类型的对象，这叫多态，即一种类型的变量，可引用多种实际类型对象。这样，对于变量shape，它就有两个类型：类型Shape，我们称之为shape的静态类型；类型Circle/Line/ArrowLine，我们称之为shape的动态类型。一个Shape类型的数组，shapes[i].draw()调用的是其对应动态类型的draw方法，这称之为方法的**动态绑定**。
- 为什么要有多态和动态绑定呢？创建对象的代码和操作对象的代码，经常不在一起，操作对象的代码往往只知道对象是某种父类型，也往往只需要知道它是某种父类型就可以了。可以说，多态和动态绑定是计算机程序的一种重要思维方式，使得操作对象的程序不需要关注对象的实际类型，从而可以统一处理不同对象，但又能实现每个对象的特有行为。
##### 小结
- 1）每个类有且只有一个父类，没有声明父类的，其父类为Object，子类继承了父类非private的属性和方法，可以增加自己的属性和方法，以及重写父类的方法实现。
- 2）new过程中，父类先进行初始化，可通过super调用父类相应的构造方法，没有使用super的情况下，调用父类的默认构造方法。
- 3）子类变量和方法与父类重名的情况下，可通过super强制访问父类的变量和方法。
- 4）子类对象可以赋值给父类引用变量，这叫多态；实际执行调用的是子类实现，这叫动态绑定。
#### 继承的细节
##### 构造方法
子类可以通过super调用父类的构造方法，如果子类没有通过super调用，则会自动调动父类的默认构造方法，那如果父类没有默认构造方法，它的任何子类都必须在构造方法中通过super调用带参数构造方法，否则，Java会提示编译错误。

如果在父类构造方法中调用了可被重写的方法，则可能会出现意想不到的结果：
![img_2.png](img_2.png)
![img_3.png](img_3.png)
第一次输出为0，第二次输出为123。第一行为什么是0呢？第一次输出是在new过程中输出的，在new过程中，首先是初始化父类，父类构造方法调用test()方法，test()方法被子类重写了，就会调用子类的test()方法，子类方法访问子类实例变量a，而这个时候子类的实例变量的赋值语句和构造方法还没有执行，所以输出的是其默认值0。像这样，**在父类构造方法中调用可被子类重写的方法，是一种不好的实践，容易引起混淆，应该只调用private的方法**。
##### 重名与静态绑定
子类可以重写父类非private的方法，当调用的时候，会动态绑定，执行子类的方法。实例变量、静态方法和静态变量重名也是可以的，重名后实际上有两个变量或方法。private变量和方法只能在类内访问，访问的也永远是当前类的，即：在子类中访问的是子类的；在父类中访问的是父类的，它们只是碰巧名字一样而已，没有任何关系。public变量和方法，则要看如何访问它。在类内，访问的是当前类的，但子类可以通过super．明确指定访问父类的。在类外，则要看访问变量的静态类型：静态类型是父类，则访问父类的变量和方法；静态类型是子类，则访问的是子类的变量和方法。
![img_4.png](img_4.png)
![img_5.png](img_5.png)
**当通过b（静态类型Base）访问时，访问的是Base的变量和方法，当通过c（静态类型Child）访问时，访问的是Child的变量和方法，这称之为静态绑定，即访问绑定到变量的静态类型。静态绑定在程序编译阶段即可决定，而动态绑定则要等到程序运行时。实例变量、静态变量、静态方法、private方法，都是静态绑定的。**

#### 重载和重写
重载是指方法名称相同但参数签名不同（参数个数、类型或顺序不同），重写是指子类重写与父类相同参数签名的方法。
**当有多个重名函数的时候，在决定要调用哪个函数的过程中，首先是按照参数类型进行匹配的，换句话说，寻找在所有重载版本中最匹配的，然后才看变量的动态类型，进行动态绑定。**
##### 父子类型转换
一个父类的变量能不能转换为一个子类的变量，取决于这个父类变量的动态类型（即引用的对象类型）是不是这个子类或这个子类的子类。给定一个父类的变量能不能知道它到底是不是某个子类的对象，从而安全地进行类型转换呢？答案是可以，通过instanceof关键字
##### 继承访问权限protected
变量和函数有public/private修饰符，public表示外部可以访问，private表示只能内部使用，还有一种可见性介于中间的修饰符protected，表示虽然不能被外部任意访问，但可被子类访问。另外，protected还表示可被同一个包中的其他类访问，不管其他类是不是该类的子类。

基类定义了表示对外行为的方法action，并定义了可以被子类重写的两个步骤step1()和step2()，以及被子类查看的变量currentStep，子类通过重写protected方法step1()和step2()来修改对外的行为。这种思路和设计是一种设计模式，称之为模板方法。action方法就是一个模板方法，它定义了实现的模板，而具体实现则由子类提供。模板方法在很多框架中有广泛的应用，这是使用protected的一种常见场景。
##### 可见性重写
重写方法时，一般并不会修改方法的可见性。但重写时，子类方法不能降低父类方法的可见性。不能降低是指，父类如果是public，则子类也必须是public，父类如果是protected，子类可以是protected，也可以是public，即子类可以升级父类方法的可见性但不能降低。

为什么要这样规定呢？继承反映的是“is-a”的关系，即子类对象也属于父类，子类必须支持父类所有对外的行为，将可见性降低就会减少子类对外的行为，从而破坏“is-a”的关系，但子类可以增加父类的行为，所以提升可见性是没有问题的。

##### 防止继承final
有的时候甚至不希望类被继承，可以通过final关键字实现。final关键字可以修饰变量，而这是final的另一种用法。一个Java类，默认情况下都是可以被继承的，但加了final关键字之后就不能被继承了。
一个非final的类，其中的public/protected实例方法默认情况下都是可以被重写的，但加了final关键字后就不能被重写了。
#### 继承实现的基本原理
仔细看书4.3，代码已同步到src/com.logicalJava.extend
#### 类加载过程
在Java中，所谓类的加载是指将类的相关信息加载到内存。在Java中，类是动态加载的，当第一次使用这个类的时候才会加载，加载一个类时，会查看其父类是否已加载，如果没有，则会加载其父类。一个类的信息主要包括以下部分：
- 类变量（静态变量）；
- 类初始化代码；包括：定义静态变量时的赋值语句；静态初始化代码块。
- 类方法（静态方法）；
- 实例变量；
- 实例初始化代码；包括：定义实例变量时的赋值语句；实例初始化代码块；构造方法。
- 实例方法；
- 父类信息引用。 

类加载过程包括：
- 分配内存保存类的信息；
- 给类变量赋默认值；
- 加载父类； 
- 设置父子关系；
- 执行类初始化代码。类初始化代码，是先执行父类的，再执行子类的。不过，父类执行时，子类静态变量的值也是有的，是默认值。

存放类的信息，这个区在Java中称为方法区。加载后，Java方法区就有了一份这个类的信息。
##### 对象创建过程
在类加载之后，new Child()就是创建Child对象，创建对象过程包括：
- 1）分配内存；
- 2）对所有实例变量赋默认值；
- 3）执行实例初始化代码。
  
分配的内存包括本类和所有父类的实例变量，但不包括任何静态变量。实例初始化代码的执行从父类开始，再执行子类的。但在任何类执行初始化代码之前，所有实例变量都已设置完默认值。每个对象除了保存类的实例变量之外，还保存着实际类信息的引用。Child c = new Child()；会将新创建的Child对象引用赋给变量c，而Base b = c；会让b也引用这个Child对象。创建和赋值后，内存布局如图：
![img_6.png](img_6.png)
##### 方法调用的过程
寻找要执行的实例方法的时候，是从对象的实际类型信息开始查找的，找不到的时候，再查找父类类型信息。而动态绑定实现的机制就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类。如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要进行很多次查找。**大多数系统使用一种称为虚方法表的方法来优化调用的效率**。所谓虚方法表，就是在类加载的时候为每个类创建一个表，记录该类的对象所有动态绑定的方法（包括父类的方法）及其地址，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。对于本例来说，Child和Base的虚方法表如图所示：
![img_7.png](img_7.png)
对Child类型来说，action方法指向Base中的代码，toString方法指向Object中的代码，而step()指向本类中的代码。当通过对象动态绑定方法的时候，只需要查找这个表就可以了，而不需要挨个查找每个父类。
##### 变量的访问过程
对变量的访问是静态绑定的，无论是类变量还是实例变量。代码中演示的是类变量：通过对象访问类变量，系统会转换为通过类直接访问类变量。例子中的实例变量都是private的，不能直接访问；如果是public的，则b.a访问的是对象中Base类定义的实例变量a，而c.a访问的是对象中Child类定义的实例变量a。
#### 继承是双刃剑
##### 继承破坏封装
封装是程序设计的第一原则，没有封装，代码之间会到处存在着实现细节的依赖，构建和维护复杂的程序是难以想象的。继承可能破坏封装是因为子类和父类之间可能存在着实现细节的依赖。子类在继承父类的时候，往往不得不关注父类的实现细节，而父类在修改其内部实现的时候，如果不考虑子类，也往往会影响到子类。

看书4.4.2 封装是如何被破坏的例子。

子类和父类之间是细节依赖，子类扩展父类，仅仅知道父类能做什么是不够的，还需要知道父类是怎么做的，而父类的实现细节也不能随意修改，否则可能影响子类。更具体地说，子类需要知道父类的可重写方法之间的依赖关系，具体到上例中，就是add和addAll方法之间的关系，而且这个依赖关系，父类不能随意改变。
而且父类不能随意增加公开方法，因为给父类增加就是给所有子类增加，而子类可能必须要重写该方法才能确保方法的正确性。
##### 继承没有反映is-a关系
继承关系是设计用来反映is-a关系的。但现实中，设计完全符合is-a关系的继承关系是困难的。比如，绝大部分鸟都会飞，可能就想给鸟类增加一个方法fy()表示飞，但有一些鸟就不会飞，比如企鹅。

继承是应该被当作is-a关系使用的，但是，Java并没有办法约束，父类有的属性和行为，子类并不一定都适用，子类还可以重写方法，实现与父类预期完全不一样的行为。但对于通过父类引用操作子类对象的程序而言，它是把对象当作父类对象来看待的，期望对象符合父类中声明的属性和行为。

##### 如何应对继承的双面性
1、避免继承，有三种方法：
- 使用final关键字：给类或方法方法添加final修饰符
- 优先使用组合而非继承：使用组合可以抵挡父类变化对子类的影响，从而保护子类。
- 使用接口：见下一章

2、正确使用继承
使用继承大概主要有三种场景：1）基类是别人写的，我们写子类；2）我们写基类，别人可能写子类；3）基类、子类都是我们写的。
- 第1种场景中，基类主要是Java API、其他框架或类库中的类，在这种情况下，我们主要通过扩展基类，实现自定义行为，这种情况下需要注意的是：重写方法不要改变预期的行为；阅读文档说明，理解可重写方法的实现机制，尤其是方法之间的依赖关系；在基类修改的情况下，阅读其修改说明，相应修改子类。
- 第2种场景中，需要注意的是：使用继承反映真正的is-a关系，只将真正公共的部分放到基类；对不希望被重写的公开方法添加final修饰符；写文档，说明可重写方法的实现机制，为子类提供指导，告诉子类应该如何重写；在基类修改可能影响子类时，写修改说明。
- 第3种场景，我们既写基类也写子类，关于基类，注意事项和第2种场景类似，关于子类，注意事项和第1种场景类似。

### 类的扩展
#### 接口的本质
很多时候，我们实际上关心的，并不是对象的类型，而是对象的能力，只要能提供这个能力，类型并不重要。比如要将冷水加热，只要能得到热水即可，至于是用电磁炉加热，用燃气灶加热，还是用电热水壶加热，并不重要，即重要的是对象是否有加热水的能力，而并不关心对象到底是什么类型。在这些情况中，类型并不重要，重要的是能力。那如何表示能力呢？接口
##### 接口的概念
接口声明了一组能力，但它自己并没有实现这个能力，它只是一个约定。接口涉及交互两方对象，一方需要实现这个接口，另一方使用这个接口，但双方对象并不直接互相依赖，它们只是通过接口间接交互。
##### 定义接口
比较能力的接口，如下：
```
    public interface MyComparable(){
        int compareTo(Object other);
    }
```
1）Java使用interface这个关键字来声明接口，修饰符一般都是public。2）interface后面就是接口的名字MyComparable。3）接口定义里面，声明了一个方法compareTo，但没有定义方法体，**Java 8之前，接口内不能实现方法**。接口方法不需要加修饰符，加与不加相当于都是public abstract。

##### 实现接口
类可以实现接口，表示类的对象具有接口所表示的能力。
- Java使用implements这个关键字表示实现接口，前面是类名，后面是接口名。
- 实现接口必须要实现接口中声明的方法，比如实现了MyComparable接口的类必须实现compareTo方法。
- 一个类可以实现多个接口，表明类的对象具备多种能力，各个接口之间以逗号分隔。
##### 使用接口
与类不同，接口不能new，不能直接创建一个接口对象，对象只能通过类来创建。但可以声明接口类型的变量，引用实现了接口的类对象。比如，可以这样：
```
  class Point implements MyComparable{
        @Override
        public int compareTo(Object other){
            ....;
        }
  }
  
  MyComparable p = new Point();
```
如果一个类型实现了多个接口，那么这种类型的对象就可以被赋值给任一接口类型的变量.

在一些程序中，代码并不知道具体的类型，这才是接口发挥威力的地方。看书中5.1.4的使用MyComparable接口的例子

**针对接口而非具体类型进行编程，是计算机程序的一种重要思维方式。接口很多时候反映了对象以及对对象操作的本质。它的优点有很多，首先是代码复用，同一套代码可以处理多种不同类型的对象，只要这些对象都有相同的能力。接口更重要的是降低了耦合，提高了灵活性。用接口的代码依赖的是接口本身，而非实现接口的具体类型，程序可以根据情况替换接口的实现，而不影响接口使用者**
##### 接口的细节
- 变量修饰符是public static final，但这个修饰符是可选的，即使不写，也是public static final。这个变量可以通过“接口名．变量名”的方式使用
- 接口也可以继承，一个接口可以继承其他接口，继承的基本概念与类一样，但与类不同的是，接口可以有多个父接口。
- 类的继承与接口可以共存，换句话说，类可以在继承基类的情况下，同时实现一个或多个接口，关键字extends要放在implements之前。
- 接口也可以使用instanceof关键字，用来判断一个对象是否实现了某接口。
##### 使用接口代替继承
见书上解释，我还有点没理解
##### Java 8和Java 9对接口的增强
- 在Java 8之前，接口中的方法都是抽象方法，都没有实现体，Java 8允许在接口中定义两类新方法：静态方法和默认方法，它们有实现体。
- 默认方法用关键字default表示。默认方法与抽象方法都是接口的方法，不同在于，默认方法有默认的实现，实现类可以改变它的实现，也可以不改变。引入默认方法主要是函数式数据处理的需求，是为了便于给接口增加功能。
- 在Java 8中，静态方法和默认方法都必须是public的，Java 9去除了这个限制，它们都可以是private的，引入private方法主要是为了方便多个静态或默认方法复用代码。
#### 抽象类
抽象类就是抽象的类。抽象是相对于具体而言的，一般而言，具体类有直接对应的对象，而抽象类没有，它表达的是抽象概念，一般是具体类的比较上层的父类。比如，狗是具体对象，而动物则是抽象概念；樱桃是具体对象，而水果则是抽象概念；正方形是具体对象，而图形则是抽象概念。
##### 抽象方法和抽象类
- 只有子类才知道如何实现的方法，一般被定义为抽象方法。抽象方法和抽象类都使用abstract这个关键字来声明，语法如下所示：
```
    public abstract class Shape{
        public abstract void draw();
    }
```
- 定义了抽象方法的类必须被声明为抽象类，不过，抽象类可以没有抽象方法。抽象类和具体类一样，可以定义具体方法、实例变量等，**它和具体类的核心区别是，抽象类不能创建对象**。
- 一个类在继承抽象类后，必须实现抽象类中定义的所有抽象方法，除非它自己也声明为抽象类
- 与接口类似，抽象类虽然不能使用new，但可以声明抽象类的变量，引用抽象类具体子类的对象
##### 为什么需要抽象类
使用抽象方法而非空方法体，子类就知道它必须要实现该方法，而不可能忽略，若忽略Java编译器会提示错误。使用抽象类，类的使用者创建对象的时候，就知道必须要使用某个具体子类，而不可能误用不完整的父类。
##### 抽象类和接口
抽象类和接口有类似之处：都不能用于创建对象，接口中的方法其实都是抽象方法。如果抽象类中只定义了抽象方法，那抽象类和接口就更像了。但抽象类和接口根本上是不同的，接口中不能定义实例变量，而抽象类可以，一个类可以实现多个接口，但只能继承一个类。**抽象类和接口是配合而非替代关系，它们经常一起使用，接口声明能力，抽象类提供默认实现，实现全部或部分方法，一个接口经常有一个对应的抽象类**
### 内部类
一个类还可以放在另一个类的内部，称之为内部类，相对而言，包含它的类称之为外部类。

内部类与包含它的外部类有比较密切的关系，而与其他类关系不大，定义在类内部，可以实现对外部完全隐藏，可以有更好的封装性，代码实现上也往往更为简洁。

不过，内部类只是Java编译器的概念，对于Java虚拟机而言，它是不知道内部类这回事的，每个内部类最后都会被编译为一个独立的类。内部类可以方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏，相关代码写在一起，写法也更为简洁，这些都是内部类的好处

在Java中，根据定义的位置和方式不同，主要有4种内部类：
- 静态内部类
- 成员内部类。
- 方法内部类。
- 匿名内部类。
##### 静态内部类
![img_8.png](img_8.png)
静态内部类带有static修饰符。语法上，静态内部类除了位置放在其他类内部外，它与一个独立的类差别不大。静态内部类与外部类的联系也不大（与其他内部类相比）。它可以访问外部类的静态变量和方法，但不可以访问实例变量和方法。在类内部，可以直接使用内部静态类，如test()方法所示。public静态内部类可以被外部使用，只是需要通过“外部类．静态内部类”的方式使用
##### 成员内部类
![img_9.png](img_9.png)
与静态内部类不同，它没有static修饰，除了静态变量和方法，成员内部类还可以直接访问外部类的实例变量和方法。成员内部类还可以通过“外部类．this.xxx”的方式引用外部类的实例变量和方法，如Outer.this. action()，这种写法一般在重名的情况下使用，如果没有重名，那么“外部类．this. ”是多余的。在外部类内，使用成员内部类与静态内部类是一样的，直接使用即可，如test()方法所示。与静态内部类不同，成员内部类对象总是与一个外部类对象相连的，在外部使用时，它不能直接通过new Outer.Inner()的方式创建对象，而是要先将创建一个Outer类对象，创建内部类对象的语法是“外部类对象．new 内部类()”。

与静态内部类不同，成员内部类中不可以定义静态变量和方法（final变量例外，它等同于常量），下面介绍的方法内部类和匿名内部类也都不可以。Java为什么要有这个规定呢？可以这么理解，这些内部类是与外部实例相连的，不应独立使用，而静态变量和方法作为类型的属性和方法，一般是独立使用的，在内部类中意义不大，而如果内部类确实需要静态变量和方法，那么也可以挪到外部类中。

##### 方法内部类
方法内部类只能在定义的方法内被使用。如果方法是实例方法，则除了静态变量和方法，内部类还可以直接访问外部类的实例变量和方法。如果方法是静态方法，则方法内部类只能访问外部类的静态变量和方法。方法内部类还可以直接访问方法的参数和方法中的局部变量，不过，这些变量必须被声明为final。
##### 
![img_10.png](img_10.png)
匿名内部类没有单独的类定义，它在创建对象的同时定义类。匿名内部类是与new关联的，在创建对象的时候定义类，new后面是父类或者父接口，然后是圆括号()，里面可以是传递给父类构造方法的参数，最后是大括号{}，里面是类的定义。

匿名内部类只能被使用一次，用来创建一个对象。它没有名字，没有构造方法，但可以根据参数列表，调用对应的父类构造方法。它可以定义实例变量和方法，可以有初始化代码块，初始化代码块可以起到构造方法的作用，只是构造方法可以有多个，而初始化代码块只能有一份。因为没有构造方法，它自己无法接受参数，如果必须要参数，则应该使用其他内部类。与方法内部类一样，匿名内部类也可以访问外部类的所有变量和方法，可以访问方法中的final参数和局部变量。

#### 枚举
枚举是一种特殊的数据，它的取值是有限的，是可以枚举出来的，比如一年有四季、一周有七天。虽然使用类也可以处理这种数据，但枚举类型更为简洁、安全和方便。

枚举使用enum这个关键字来定义，值一般是大写的字母，多个值之间以逗号分隔。枚举类型可以定义为一个单独的文件，也可以定义在其他类内部。
```
    public enum Size{
        SMALL,MEDIUM,LARGE
    }
    
    //使用
    Size size = Size.MEDIUM;
```

