### Java的基本程序设计结构
#### 数据类型
##### 整型
- Java提供了4种整型:byte,short,int,long.
- Java中，整型的范围与运行Java代码的机器无关，而在C++中，int 和long等类型的大小与目标平台相关.
- 长整型有一个L或l后缀，十六进制有一个0X或0x前缀，八进制有一个0前缀，Java 7起，加上前缀0b或0B就可以写二进制数.
- Java没有任何无符号形式的int/long/short/byte.
##### 浮点类型
- float精度是6-7位有效数字，double精度是float的二倍
- float类型的数只有一个后缀F或f，没有后缀的浮点数默认为double
##### char类型
- 有些Unicode字符可用一个char值描述，另外一些需要两个
- char类型的字面量值要用单引号括起来
##### boolean类型
- Java中整型值和布尔值不能互相转换，在C++中，值0相当于false,非0值相当于true.
#### 变量与常量
- 变量名必须是一个以字母开头并由字母和数字组成的序列，不能使用保留字作为变量名
- 声明一个变量后，必须用赋值语句对变量进行显示初始化，变量的声明尽可能地靠近第一次使用的地方.
- Java 10 开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不需要声明类型。只需要使用关键字var而无需指定类型，如var greeting = "hello";则greeting是一个字符串
- 关键字final表示常量，一旦赋值就不能再更改了，通常，常量名使用全大写.
- 类常量的定义位于main方法的外部
#### 枚举类型
- 变量的取值只在一个有限的集合内时，可以定义枚举类型。如， enum Size {Small, Medium, Large};然后声明这种类型的变量:Size s = Size.Small.
#### 运算
- Math类中包含了各种数学函数，在文件顶部加入import static java.lang.Math.*;就可以直接使用方法，不必加前缀了
- 一个二元运算符连接两个值时，要先将两个操作数转为同一个数据类型，如果一个是double，另一个转换为double；否则如果一个是float，另一个会转为float;否则其中一个是long,另一个转为long；否则两个操作数都转为int
- 将double转为int这种会损失信息的转换需要通过强制类型转换完成，即在圆括号中给出想要转换的目标类型，比如
  double x = 9.999; int nx = (int)x;   
- 如果想要对浮点数进行舍入运算，需要使用Math.round方法。如，int nx = (int)Math.round(x);使用强制转换的原因是round返回的类型为long.
#### 字符串
- Java字符串就是Unicode字符序列，用双引号括起来.
- substring(0,3)表示提取0-3的子串，不包括位置3.
- Java字符串与一个非字符串的值拼接时，后者会转换为字符串
- 如果把多个字符串拼接在一起，并指定一个分隔符，可以使用join方法。如String all = String.join("/","S","M","L");
- 不能修改Java字符串中的单个字符
- 使用equals方法检测两个字符串是否相等，而不是使用==.
- 使用if(str.length()==0)或if(str.equals(""))判断空串
- 使用if(str == null)判断是否为null
- String的相关API在书50页
- 如果需要使用小段字符串来构建一个字符串，使用StringBuilder.
#### 输入与输出
- 读取控制台输入需要构造一个与"标准输入流"System.in关联的Scanner对象.Scanner in= new Scanner(System.in);
- nextLine方法将读取一行输入，nextInt读取一个整数，nextDouble读取下一个浮点数,next读取输入的下一个单词(以空格为分隔符),hasNext检测是否输入中还有其他单词.
- System.out.printf可以格式化输出，假如x = 3333.3333333，System.out.printf(%8.2f, x);表示以8个字符的宽度打印x，精度为小数点后2位。也就是说会打印一个前导空格和7个字符(3333.33).
- 每个以%字符开始的格式说明符都用相应的参数替换，常见的格式转换符有，d表示十进制数，x表示十六进制数，o表示八进制数，f表示定点浮点数，e表示指数浮点数，s表示字符串,c表示字符.
#### 控制流程
- 块(即复合语句)是指由若干条Java语句组成的代码块，并用一对大括号括起来.
- 条件语句if 
- 循环语句for,while
- 多重选择switch，switch(choice){case 1: ...break;default: ... break;};switch语句将从与选项值匹配的case标签开始，直到遇到break语句或到switch语句的结束处为止。如果没有匹配的case标签而有default字句，就执行这个语句.
- case标签可以是char/short/byte/int，枚举常量，Java 7开始还可以是字符串.
#### 大数
- 如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math中的BigInteger和BigDecimal。使用静态的valueOf方法可以将普通的数转为大叔，如BigInteger a = BigInteger.valueOf(100)；
- 不能使用算术运算符如+-*/处理大数，需要使用类中的方法，如add,multiply,divide等
#### 数组
- 声明，初始化，访问，for each循环遍历
- 如果希望将一个数组的所有值拷贝到一个新的数组，使用Arrays类的copyOf方法，第一个参数是源数组，第二个参数是新数组长度.
### 对象与类
##### 类之间的常见关系
- 依赖：use-a,一个类使用或者操作另一个类，就说一个类依赖于另一个类，应该尽可能将相互依赖的类减少，也就是降低类之间的耦合。
- 聚合：即has-a,一个类包含另一个类
- 继承：is-a,一个更特殊的类与一个更一般的类之间的关系。
##### 对象与对象变量
- 类的实例称为对象，要使用对象，必须要先构造对象并初始化，才能使用对象的方法.
- Date deadline = new Date();有两个部分： new Date构造了一个Date类型的对象，他的值是新创建对象的一个引用，这个引用存储在变量deadline中.
- 所有的Java对象都存储在堆中，当一个对象包含另一个对象变量时，只是包含着另一个堆对象的指针.

##### 构造器
- 构造器与类同名
- 每个类可以有一个以上的构造器
- 构造器可以有0个、1个或多个参数
- 构造器没有返回值
- 构造器总是伴着new 操作符一起使用
- 不要在构造器中定义与实例字段同名的局部变量,这些局部变量会屏蔽同名的实例字段.
##### 封装
如果想要获得或设置实例字段的值，那么只需要提供下面三项内容：

- 一个私有的数据字段
- 一个公共的访问字段的方法
- 一个公共的更改字段的方法
##### 基于类的访问权限
- 方法可以访问调用这个方法的对象的私有数据
- 一个方法可以访问所属类的所有对象的私有数据
- 在设计一个类时，由于公共数据非常危险，所以应该讲所有的数据字段都设置为私有的.
- 通常，为了实现某个公共接口的一些辅助方法，最好设计为私有
##### 静态字段与静态方法
- static修饰的字段，它属于类，不属于任何单个的对象；而非静态的实例字段，每个对象都有自己的一个副本.
- 静态变量使用的比较少，但在类中定义一个静态常量却很常用
- 静态方法不能访问实力字段，可以使用类名或者对象调用静态方法，但是建议使用类名来调用静态方法
- 可以使用静态工厂方法代替构造器来构造对象
##### 方法参数
- Java采用按值调用，也就是方法得到的是参数值的一个副本
- Java有两种类型的方法参数，基本数据类型(数字、布尔值)和对象引用，方法可以改变对象参数的内部状态但不能让一个对象参数引用一个新的对象
##### 对象构造
- 多个方法有相同的名字、不同的参数，就出现了重载
- Java允许重载任何方法，而不只是构造器方法。要完整描述一个方法，需要指定方法名以及参数，这叫方法的签名。
- 如果在构造器中没有显式为字段设置初值，就会被自动赋为默认值，数值为0，布尔为false,对象应用为null.方法中的变量必须明确初始化
- 如果写一个类时没有写构造器，那么JVM会提供一个无参构造器，这个构造器将所有的字段设置为默认值
- 如果类中提供了至少一个构造器但是没有提供无参构造器，那么构造对象时如果提供参数就是不合法的
- 可以直接在类定义中直接为任何字段赋值，在执行构造器之前会完成这个赋值操作。如果一个类的所有构造器都希望把某个字段设置为一个值，这个语法就很有用
- 如果构造器的第一语句形如this(...)，这个构造器将调用同一个类的另一个构造器
- 静态字段的初始化在类的第一次加载时执行，默认值是0、false或null.所有的静态字段和静态代码都按照类中声明的顺序执行
- 看书中132页的程序4-5，展示了本节的特性
#### 包
- Java允许使用包将类组织在一个集合中，使用包的主要原因是确保类名唯一性，同名类放在不同包中就不会产生冲突。
- 有一种import语句允许导入静态方法金额静态字段而不只是类，如import java.lang.System.*
- 没有指定public或private的类可以被同一个包中的所有方法访问
- 140页类路径
##### 类设计技巧
- 一定保证数据私有
- 一定要对数据进行初始化。可以提供默认值，也可以在所有的构造器中设置默认值
- 不用在类中使用过多的基本类型。用其他的类替换使用多个相关的基本类型，例如用一个Address类替换一个Customer类的地址相关的实例字段。
- 不是所有的字段都需要单独的字段访问器和字段更改器。如一些不需要或者不希望获得或设置的实例字段
- 分解有过多职责的类。看153页的例子
- 类名和方法名要能体现他们的指责。类名应当是一个名词(Order)或前面有形容词修饰的名词(RushOrder)或是有动名词修饰的名词(BillingAddress)。对于方法，遵循标准惯例。
- 优先使用不可变的类。如果类是不可变的，就可以安全地在多个线程间共享其对象。

## 继承
#### 超类和子类
##### 定义子类
- extends表明正在构造的新类派生于一个已存在的类，这个已存在的类称为超类或基类或父类，新类称为派生类或子类
- 子类比父类拥有的功能更多，在设计类时，把最一般的方法放在父类中，更特殊的方法放在子类，子类会自动基础父类中的方法
##### 覆盖方法
- 父类中的有些方法可能对子类并不一定适用，因此子类需要提供一个新的方法*覆盖*父类中的这个方法
- *super*关键字可以调用父类的某个方法
- 在覆盖一个方法时，子类方法不能低于父类方法的可见性
##### 子类构造器
- 语句super(name,salary)是"调用父类中带有name和salary参数的构造器"的简写形式
- 使用super调用构造器的语句必须是子类构造器的第一条语句
- 如果子类的构造器没有显式地调用父类的构造器，将自动调用父类的无参构造器，如果父类没有无参构造器，并且在子类的构造器中又没有显示地调用父类的其他构造器，则编译器会报告错误
##### 继承层次
- 由一个公共基类派生出的所有类的集合称为继承层次，在继承层次中，从某个特定的类到其祖先的路径称为该类的继承链
- 通常，一个祖先类可以有多个子孙链 
- 使用final修饰类，则不允许其被扩展；类中的方法被声明为final则表示子类不能覆盖这个方法(final类中的所有方法自动地成为final方法)
- 在继承层次内可以进行强制类型转换，在将父类强制转换为子类前，要使用instance of进行检查，查看是否能够成功的转换
##### 多态
- 可以使用"is-a"规则判断是否将数据设计为继承关系，即子类的每个对象也是父类的对象，比如每个经理也是员工
- "is-a"规则的另一种表述是替换原则，它指出程序中出现父类对象的任何地方都可以使用子类对象替换，例如，可以将子类的对象赋值父类对象，不过不能父类的引用赋值给子类变量
- 理解方法调用，看书165页
- 如果是private/static/final方法或者构造器方法，那么编译器可以准确知道应该调用那个方法，这称为静态绑定 
- 如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时使用动态绑定。动态绑定的一个重要特性是：无须对现有的代码进行修改就可以对程序进行扩展
##### 抽象类
- 为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的，即使用abstract修饰类和抽象方法
- 除了抽象方法外，抽象类还可以包含字段和具体方法
- 扩展抽象类有两种选择，一是在子类中保留抽象类中的部分或所有抽象方法仍为定义，这样就必须将子类也标记为抽象类；另一种是定义全部方法，这样一来子类就不是抽象的了
- 即使不包含抽象方法，也可以将类声明为抽象类
- 抽象类不能实例化，如果一个类被声明为abstract，就不能创建这个类的对象，但可以创建一个具体子类的对象。
- 可以定义一个抽象类的对象变量，但是这个变量只能引用非抽象的子类对象
- 看171页-173的代码及文章
##### 受保护访问
- 父类的方法或字段设置为protected，则只有本宝及其子类可以访问
#### Object：所有类的父类
- 书174也开始看，主要是几个方法介绍及代码示例。
#### 泛型数组列表
- ArrayList的声明和构造，以及add、remove、size等方法
- 不能使用[]语法而是访问或改变ArrayList元素，而要使用get和set方法
#### 对象包装器与自动装箱
- Integer等包装器不可变，也不能派生他们的子类
- 装箱和拆箱是编译器要做的，而不是虚拟机
- 如果在条件表达式中混用Integer和Double，Integer会先拆箱为提升为double,再装箱为Doube
- 看195页中间的包装类API
#### 参数可变的方法和枚举类
- 看书196页
#### 反射
- 按书上写的，暂时跳过，以后再学
#### 继承的设计技巧
- 将公共操作和字段放在父类中
- 不要使用protected修饰的字段，不过protected方法在对于指示那些不提供一般用途而应在子类中重新顶一顶方法很有用
- 使用继承实现"is-a"关系
- 除非所有继承的方法都有意义，否则不要使用继承。
- 在覆盖方法时，不要改变预期的行为
- 使用多态而不要使用类型信息
- 不要滥用反射
- 以上哪条不理解，看书中220页详细解释
###接口、lambda表达式与内部类
#### 接口
##### 接口的概念
- 在Java中，接口不是类，而是对希望符合这个接口的类的一组需求。
- 接口的所有方法都是自动public的，因此在接口中声明方法时，不必提供public关键字
- 为了实现一个接口，通常需要完成两个步骤，将类声明为实现(implements)给定的接口，对接口中所有方法提供定义。
##### 接口的特性
- 接口不是类，不能使用new运算符实例化一个接口，
- 可以声明接口类型的变量，但是接口变量必须引用实现了这个接口的类对象
- 在接口中不能包含实例字段，但是可以包含常量
- 接口中的字段总是public static final
- 尽管每个类只能有一个父类，但却可以实现多个接口
- 在Java 8中，允许在接口中增加静态方法，在Java 9中，接口的方法可以是private。
- 可以为接口方法提供一个默认实现，必须用default修饰符标记这样的方法
- 
##### 解决默认方法冲突
如果在接口中将一个方法定义为默认方法，然后在父类或者另一个接口中定义一个方法， Java的规则如下：
- 1.父类优先。如果父类提供了一个具体方法，同名且有相同参数类型的默认方法会被忽略。
- 2.接口冲突。如果两个接口提供了同名且参数类型相同的默认方法，必须覆盖这个方法来解决冲突 
##### Comparator接口和对象克隆
- 实现Comparator接口的compare方法，可以定义外部比较器
- Object默认的克隆操作是浅拷贝，并没有克隆对象中引用的其他对象
- 深拷贝：实现Cloneable接口，重新定义clone方法，并指定public访问修饰符
#### lambda表达式
##### lambda表达式的语法
- lambda表达式就是一个代码块，以及必须传入代码的变量规范，如(String first,String second)->first.length()-second.length();
- 如果在参数、箭头、表达式这种表达形式时，代码要完成的计无法放在一个表达式中，可以像写方法一样，把这些代码放在{}中，并显示包含return语句，如(String first,String second)->{code1;code2;return xxx;}
- 即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样，如()->表达式;
- 如果可以推导出一个lambda表达式的参数类型，则参数中可以忽略其类型
- 无须指定lambda表达式的返回类型，返回类型总会由上下文推导得出
##### 函数式接口
- 对于只有一个抽象方法的接口，需要这种接口的对象时，可以提供一个lambda表达式，这种接口称为*函数式接口*，如Comparator接口。Arrays.sort方法的第二个参数需要一个Comparator实例
##### 方法引用
看书吧，247页
##### 构造器引用、变量作用域、处理lambda表达式
书250页开始看
#### 内部类
##### 为什么需要内部类
- 内部类可以对同一个包中的其他类隐藏
- 内部类方法可以访问定义这个类的作用域中的数据，包括原本私有的数据，因此内部类的对象总有一个隐式引用， 指向创建它的外部类
##### 内部类的使用
从书256页开始看
#### 代理
##### 何时使用代理
- 利用代理可以在运行时创建实现了一组给定接口的新类
- 只有在编译时期无法确定需要实现哪个接口时才有必要使用代理
##### 创建代理类
看书274页
