### Java的基本程序设计结构
#### 数据类型
##### 整型
- Java提供了4种整型:byte,short,int,long.
- Java中，整型的范围与运行Java代码的机器无关，而在C++中，int 和long等类型的大小与目标平台相关.
- 长整型有一个L或l后缀，十六进制有一个0X或0x前缀，八进制有一个0前缀，Java 7起，加上前缀0b或0B就可以写二进制数.
- Java没有任何无符号形式的int/long/short/byte.
##### 浮点类型
- float精度是6-7位有效数字，double精度是float的二倍
- float类型的数只有一个后缀F或f，没有后缀的浮点数默认为double
##### char类型
- 有些Unicode字符可用一个char值描述，另外一些需要两个
- char类型的字面量值要用单引号括起来
##### boolean类型
- Java中整型值和布尔值不能互相转换，在C++中，值0相当于false,非0值相当于true.
#### 变量与常量
- 变量名必须是一个以字母开头并由字母和数字组成的序列，不能使用保留字作为变量名
- 声明一个变量后，必须用赋值语句对变量进行显示初始化，变量的声明尽可能地靠近第一次使用的地方.
- Java 10 开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不需要声明类型。只需要使用关键字var而无需指定类型，如var greeting = "hello";则greeting是一个字符串
- 关键字final表示常量，一旦赋值就不能再更改了，通常，常量名使用全大写.
- 类常量的定义位于main方法的外部
#### 枚举类型
- 变量的取值只在一个有限的集合内时，可以定义枚举类型。如， enum Size {Small, Medium, Large};然后声明这种类型的变量:Size s = Size.Small.
#### 运算
- Math类中包含了各种数学函数，在文件顶部加入import static java.lang.Math.*;就可以直接使用方法，不必加前缀了
- 一个二元运算符连接两个值时，要先将两个操作数转为同一个数据类型，如果一个是double，另一个转换为double；否则如果一个是float，另一个会转为float;否则其中一个是long,另一个转为long；否则两个操作数都转为int
- 将double转为int这种会损失信息的转换需要通过强制类型转换完成，即在圆括号中给出想要转换的目标类型，比如
  double x = 9.999; int nx = (int)x;   
- 如果想要对浮点数进行舍入运算，需要使用Math.round方法。如，int nx = (int)Math.round(x);使用强制转换的原因是round返回的类型为long.
#### 字符串
- Java字符串就是Unicode字符序列，用双引号括起来.
- substring(0,3)表示提取0-3的子串，不包括位置3.
- Java字符串与一个非字符串的值拼接时，后者会转换为字符串
- 如果把多个字符串拼接在一起，并指定一个分隔符，可以使用join方法。如String all = String.join("/","S","M","L");
- 不能修改Java字符串中的单个字符
- 使用equals方法检测两个字符串是否相等，而不是使用==.
- 使用if(str.length()==0)或if(str.equals(""))判断空串
- 使用if(str == null)判断是否为null
- String的相关API在书50页
- 如果需要使用小段字符串来构建一个字符串，使用StringBuilder.
#### 输入与输出
- 读取控制台输入需要构造一个与"标准输入流"System.in关联的Scanner对象.Scanner in= new Scanner(System.in);
- nextLine方法将读取一行输入，nextInt读取一个整数，nextDouble读取下一个浮点数,next读取输入的下一个单词(以空格为分隔符),hasNext检测是否输入中还有其他单词.
- System.out.printf可以格式化输出，假如x = 3333.3333333，System.out.printf(%8.2f, x);表示以8个字符的宽度打印x，精度为小数点后2位。也就是说会打印一个前导空格和7个字符(3333.33).
- 每个以%字符开始的格式说明符都用相应的参数替换，常见的格式转换符有，d表示十进制数，x表示十六进制数，o表示八进制数，f表示定点浮点数，e表示指数浮点数，s表示字符串,c表示字符.
#### 控制流程
- 块(即复合语句)是指由若干条Java语句组成的代码块，并用一对大括号括起来.
- 条件语句if 
- 循环语句for,while
- 多重选择switch，switch(choice){case 1: ...break;default: ... break;};switch语句将从与选项值匹配的case标签开始，直到遇到break语句或到switch语句的结束处为止。如果没有匹配的case标签而有default字句，就执行这个语句.
- case标签可以是char/short/byte/int，枚举常量，Java 7开始还可以是字符串.
#### 大数
- 如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math中的BigInteger和BigDecimal。使用静态的valueOf方法可以将普通的数转为大叔，如BigInteger a = BigInteger.valueOf(100)；
- 不能使用算术运算符如+-*/处理大数，需要使用类中的方法，如add,multiply,divide等
#### 数组
- 声明，初始化，访问，for each循环遍历
- 如果希望将一个数组的所有值拷贝到一个新的数组，使用Arrays类的copyOf方法，第一个参数是源数组，第二个参数是新数组长度.
### 对象与类
##### 类之间的常见关系
- 依赖：use-a,一个类使用或者操作另一个类，就说一个类依赖于另一个类，应该尽可能将相互依赖的类减少，也就是降低类之间的耦合。
- 聚合：即has-a,一个类包含另一个类
- 继承：is-a,一个更特殊的类与一个更一般的类之间的关系。
##### 对象与对象变量
- 类的实例称为对象，要使用对象，必须要先构造对象并初始化，才能使用对象的方法.
- Date deadline = new Date();有两个部分： new Date构造了一个Date类型的对象，他的值是新创建对象的一个引用，这个引用存储在变量deadline中.
- 所有的Java对象都存储在堆中，当一个对象包含另一个对象变量时，只是包含着另一个堆对象的指针.

##### 构造器
- 构造器与类同名
- 每个类可以有一个以上的构造器
- 构造器可以有0个、1个或多个参数
- 构造器没有返回值
- 构造器总是伴着new 操作符一起使用
- 不要在构造器中定义与实例字段同名的局部变量,这些局部变量会屏蔽同名的实例字段.
##### 封装
如果想要获得或设置实例字段的值，那么只需要提供下面三项内容：

- 一个私有的数据字段
- 一个公共的访问字段的方法
- 一个公共的更改字段的方法
##### 基于类的访问权限
- 方法可以访问调用这个方法的对象的私有数据
- 一个方法可以访问所属类的所有对象的私有数据
- 在设计一个类时，由于公共数据非常危险，所以应该讲所有的数据字段都设置为私有的.
- 通常，为了实现某个公共接口的一些辅助方法，最好设计为私有
##### 静态字段与静态方法
- static修饰的字段，它属于类，不属于任何单个的对象；而非静态的实例字段，每个对象都有自己的一个副本.
- 静态变量使用的比较少，但在类中定义一个静态常量却很常用
- 静态方法不能访问实力字段，可以使用类名或者对象调用静态方法，但是建议使用类名来调用静态方法
- 可以使用静态工厂方法代替构造器来构造对象
##### 方法参数
- Java采用按值调用，也就是方法得到的是参数值的一个副本
- Java有两种类型的方法参数，基本数据类型(数字、布尔值)和对象引用，方法可以改变对象参数的内部状态但不能让一个对象参数引用一个新的对象
##### 对象构造
- 多个方法有相同的名字、不同的参数，就出现了重载
- Java允许重载任何方法，而不只是构造器方法。要完整描述一个方法，需要指定方法名以及参数，这叫方法的签名。
- 如果在构造器中没有显式为字段设置初值，就会被自动赋为默认值，数值为0，布尔为false,对象应用为null.方法中的变量必须明确初始化
- 如果写一个类时没有写构造器，那么JVM会提供一个无参构造器，这个构造器将所有的字段设置为默认值
- 如果类中提供了至少一个构造器但是没有提供无参构造器，那么构造对象时如果提供参数就是不合法的
- 可以直接在类定义中直接为任何字段赋值，在执行构造器之前会完成这个赋值操作。如果一个类的所有构造器都希望把某个字段设置为一个值，这个语法就很有用
- 如果构造器的第一语句形如this(...)，这个构造器将调用同一个类的另一个构造器
- 静态字段的初始化在类的第一次加载时执行，默认值是0、false或null.所有的静态字段和静态代码都按照类中声明的顺序执行
- 看书中132页的程序4-5，展示了本节的特性
#### 包
- Java允许使用包将类组织在一个集合中，使用包的主要原因是确保类名唯一性，同名类放在不同包中就不会产生冲突。
- 有一种import语句允许导入静态方法金额静态字段而不只是类，如import java.lang.System.*
- 没有指定public或private的类可以被同一个包中的所有方法访问
- 140页类路径
##### 类设计技巧
- 一定保证数据私有
- 一定要对数据进行初始化。可以提供默认值，也可以在所有的构造器中设置默认值
- 不用在类中使用过多的基本类型。用其他的类替换使用多个相关的基本类型，例如用一个Address类替换一个Customer类的地址相关的实例字段。
- 不是所有的字段都需要单独的字段访问器和字段更改器。如一些不需要或者不希望获得或设置的实例字段
- 分解有过多职责的类。看153页的例子
- 类名和方法名要能体现他们的指责。类名应当是一个名词(Order)或前面有形容词修饰的名词(RushOrder)或是有动名词修饰的名词(BillingAddress)。对于方法，遵循标准惯例。
- 优先使用不可变的类。如果类是不可变的，就可以安全地在多个线程间共享其对象。

## 继承
#### 超类和子类
##### 定义子类
- extends表明正在构造的新类派生于一个已存在的类，这个已存在的类称为超类或基类或父类，新类称为派生类或子类
- 子类比父类拥有的功能更多，在设计类时，把最一般的方法放在父类中，更特殊的方法放在子类，子类会自动基础父类中的方法
##### 覆盖方法
- 父类中的有些方法可能对子类并不一定适用，因此子类需要提供一个新的方法*覆盖*父类中的这个方法
- *super*关键字可以调用父类的某个方法
- 在覆盖一个方法时，子类方法不能低于父类方法的可见性
##### 子类构造器
- 语句super(name,salary)是"调用父类中带有name和salary参数的构造器"的简写形式
- 使用super调用构造器的语句必须是子类构造器的第一条语句
- 如果子类的构造器没有显式地调用父类的构造器，将自动调用父类的无参构造器，如果父类没有无参构造器，并且在子类的构造器中又没有显示地调用父类的其他构造器，则编译器会报告错误
##### 继承层次
- 由一个公共基类派生出的所有类的集合称为继承层次，在继承层次中，从某个特定的类到其祖先的路径称为该类的继承链
- 通常，一个祖先类可以有多个子孙链 
- 使用final修饰类，则不允许其被扩展；类中的方法被声明为final则表示子类不能覆盖这个方法(final类中的所有方法自动地成为final方法)
- 在继承层次内可以进行强制类型转换，在将父类强制转换为子类前，要使用instance of进行检查，查看是否能够成功的转换
##### 多态
- 可以使用"is-a"规则判断是否将数据设计为继承关系，即子类的每个对象也是父类的对象，比如每个经理也是员工
- "is-a"规则的另一种表述是替换原则，它指出程序中出现父类对象的任何地方都可以使用子类对象替换，例如，可以将子类的对象赋值父类对象，不过不能父类的引用赋值给子类变量
- 理解方法调用，看书165页
- 如果是private/static/final方法或者构造器方法，那么编译器可以准确知道应该调用那个方法，这称为静态绑定 
- 如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时使用动态绑定。动态绑定的一个重要特性是：无须对现有的代码进行修改就可以对程序进行扩展
##### 抽象类
- 为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的，即使用abstract修饰类和抽象方法
- 除了抽象方法外，抽象类还可以包含字段和具体方法
- 扩展抽象类有两种选择，一是在子类中保留抽象类中的部分或所有抽象方法仍为定义，这样就必须将子类也标记为抽象类；另一种是定义全部方法，这样一来子类就不是抽象的了
- 即使不包含抽象方法，也可以将类声明为抽象类
- 抽象类不能实例化，如果一个类被声明为abstract，就不能创建这个类的对象，但可以创建一个具体子类的对象。
- 可以定义一个抽象类的对象变量，但是这个变量只能引用非抽象的子类对象
- 看171页-173的代码及文章
##### 受保护访问
- 父类的方法或字段设置为protected，则只有本宝及其子类可以访问
#### Object：所有类的父类
- 书174也开始看，主要是几个方法介绍及代码示例。
#### 泛型数组列表
- ArrayList的声明和构造，以及add、remove、size等方法
- 不能使用[]语法而是访问或改变ArrayList元素，而要使用get和set方法
#### 对象包装器与自动装箱
- Integer等包装器不可变，也不能派生他们的子类
- 装箱和拆箱是编译器要做的，而不是虚拟机
- 如果在条件表达式中混用Integer和Double，Integer会先拆箱为提升为double,再装箱为Doube
- 看195页中间的包装类API
#### 参数可变的方法和枚举类
- 看书196页
#### 反射
- 按书上写的，暂时跳过，以后再学
#### 继承的设计技巧
- 将公共操作和字段放在父类中
- 不要使用protected修饰的字段，不过protected方法在对于指示那些不提供一般用途而应在子类中重新顶一顶方法很有用
- 使用继承实现"is-a"关系
- 除非所有继承的方法都有意义，否则不要使用继承。
- 在覆盖方法时，不要改变预期的行为
- 使用多态而不要使用类型信息
- 不要滥用反射
- 以上哪条不理解，看书中220页详细解释
###接口、lambda表达式与内部类
#### 接口
##### 接口的概念
- 在Java中，接口不是类，而是对希望符合这个接口的类的一组需求。
- 接口的所有方法都是自动public的，因此在接口中声明方法时，不必提供public关键字
- 为了实现一个接口，通常需要完成两个步骤，将类声明为实现(implements)给定的接口，对接口中所有方法提供定义。
##### 接口的特性
- 接口不是类，不能使用new运算符实例化一个接口，
- 可以声明接口类型的变量，但是接口变量必须引用实现了这个接口的类对象
- 在接口中不能包含实例字段，但是可以包含常量
- 接口中的字段总是public static final
- 尽管每个类只能有一个父类，但却可以实现多个接口
- 在Java 8中，允许在接口中增加静态方法，在Java 9中，接口的方法可以是private。
- 可以为接口方法提供一个默认实现，必须用default修饰符标记这样的方法
- 
##### 解决默认方法冲突
如果在接口中将一个方法定义为默认方法，然后在父类或者另一个接口中定义一个方法， Java的规则如下：
- 1.父类优先。如果父类提供了一个具体方法，同名且有相同参数类型的默认方法会被忽略。
- 2.接口冲突。如果两个接口提供了同名且参数类型相同的默认方法，必须覆盖这个方法来解决冲突 
##### Comparator接口和对象克隆
- 实现Comparator接口的compare方法，可以定义外部比较器
- Object默认的克隆操作是浅拷贝，并没有克隆对象中引用的其他对象
- 深拷贝：实现Cloneable接口，重新定义clone方法，并指定public访问修饰符
#### lambda表达式
##### lambda表达式的语法
- lambda表达式就是一个代码块，以及必须传入代码的变量规范，如(String first,String second)->first.length()-second.length();
- 如果在参数、箭头、表达式这种表达形式时，代码要完成的计无法放在一个表达式中，可以像写方法一样，把这些代码放在{}中，并显示包含return语句，如(String first,String second)->{code1;code2;return xxx;}
- 即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样，如()->表达式;
- 如果可以推导出一个lambda表达式的参数类型，则参数中可以忽略其类型
- 无须指定lambda表达式的返回类型，返回类型总会由上下文推导得出
##### 函数式接口
- 对于只有一个抽象方法的接口，需要这种接口的对象时，可以提供一个lambda表达式，这种接口称为*函数式接口*，如Comparator接口。Arrays.sort方法的第二个参数需要一个Comparator实例
##### 方法引用
看书吧，247页
##### 构造器引用、变量作用域、处理lambda表达式
书250页开始看
#### 内部类
##### 为什么需要内部类
- 内部类可以对同一个包中的其他类隐藏
- 内部类方法可以访问定义这个类的作用域中的数据，包括原本私有的数据，因此内部类的对象总有一个隐式引用， 指向创建它的外部类
##### 内部类的使用
从书256页开始看
#### 代理
##### 何时使用代理
- 利用代理可以在运行时创建实现了一组给定接口的新类
- 只有在编译时期无法确定需要实现哪个接口时才有必要使用代理
##### 创建代理类
看书274页
### 异常、断言和日志
#### 处理错误
在Java中，如果某个方法不能采用正常的途径完成他的任务，可以通过另一个途径退出方法。在这种情况下，方法不返回任何值，而是抛出(throws)一个封装了错误信息的对象。这个方法将会立即退出，并不返回正常值。也不会从调用这个方法的代码继续执行，取而代之的是，异常处理机制开始搜索能够处理这种异常情况的异常处理器。
##### 异常分类
- 所有的异常都是由Throwable继承而来，在下一层又分为Error和Exception
- Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误，你的程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了通知用户并尽力妥善的终止程序之外，你几乎无能能为力
- Exception层次结构又分解为两个分支：RuntimeException和其他异常。一般规则是：由编程错误导致的异常属于RuntimeException；如过程序本身没有问题，但由于像I/O错误这类的问题导致的异常属于其他异常
- "如果出现RuntimeException异常，那么一定就是你的问题"，这个规则很有道理
- 派生于Error或RuntimeException类的所有异常都称为非检查类型(unchecked)，所有其他的异常称为检查型(checked)异常
##### 声明检查型异常
- 方法要告诉编译器有可能发生的错误，指出这个方法可能抛出一个异常。所以要修改方法首部，以反应这个方法可能抛出的检查型异常。
- 不必声明这个方法可能抛出的所有异常，需要记住在遇到下面4种情况时会抛出异常：
1）调用了一个抛出检查型异常的方法，如FileInputStream。 2）检测到一个错误，并利用throw语句抛出一个检查型异常。3）程序出现错误，如a[-1]=0会抛出一个非检查异常。4）Java虚拟机或运行时库出现内部错误
- 如果出现前两种情况，则必须告诉调用这个方法的程序员有可能抛出异常。
- 有些Java方法包含在对外提供的类中，对于这些方法，应该通过*方法首部*的异常规范声明这个方法可能抛出异常
- 如果一个方法有可能抛出多个检查型异常类型，那么必须在方法的首部列出多有的异常类型，每个异常之间用逗号隔开
- 不应该声明从RuntimeException和Error继承的那些非检查异常
- 如果子类覆盖了父类的方法，子类中声明的检查型异常不能比父类方法中声明的异常更通用(子类可以抛出更特定的异常，或者不抛出异常)。特别是，如果父类没抛出任何检查型异常，子类也不能抛出任何检查型异常。
##### 如何抛出异常
如果一个已有的异常类能够满足你的要求，抛出这个异常如下：
- 在方法上使用*throws*声明异常
- 在方法内创建这个类的一个对象
- 使用*throw*关键字将异常抛出
- 如果已有的标准异常类无法描述清楚问题，可以自定义一个派生自Exception或其某个子类的异常类，然后在方法中抛出自定义的异常类型。
#### 捕获异常
##### 如何捕获异常
如果发送了某个异常，但是没有在任何地方捕获这个异常，程序就会终止，并在控制台打印一个消息，包括这个异常的类型和一个堆栈轨迹。

要想捕获一个异常没需要设置try/catch语句：
- 如果try语句块中的任何代码抛出了catch字句中指定的一个异常类，那么程序将跳过try语句块的其余代码，并执行catch字句中的处理器代码
- 如果try语句块中没有抛出任何异常，那么程序将跳过catch字句。
- 如果try中抛出了catch中没有声明的一个异常类型，那么这个方法就会立即退出
- 可以对不同类型的异常做出不同的处理，只需为每个异常类型使用给一个单独的catch子句即可
- 可以在catch子句中抛出一个异常

要捕获那些你知道如何处理的异常，而继续传播那些你不知道怎样处理的异常。如果想传播一个异常，就必须在方法的首部添加一个throws，提醒调用者这个方法可能会抛出异常。
##### finally子句
- 不管是否有异常被捕获，finally子句中的代码都会执行，可以用来在发生异常之后执行资源释放等操作。
- try语句可以只有finally子句，而没有catch子句
##### try-with-Resources语句
try(Resource res = ...){

work with res

}

try语句退出时，会自动调用res.close().释放资源
##### 使用异常的技巧
- 异常处理不能代替简单的测试。只在异常情况下使用异常
- 不要过分地细化异常。有必要将整个任务包在一个try中，然后用catch捕获可能出现的异常，将正常处理与错误处理分开。
- 充分利用异常层次结构。不要只抛出RuntimeException异常，应该寻找一个适合的子类或者创建自己的异常类；不要只捕获Throwable异常，否则，这会使你的代码更难读、更难维护
- 不要压制异常，如果你认为异常都非常重要，就应该适当的进行处理
#### 使用断言
##### 断言的概念
断言机制允许在测试期间向代码中插入一些检查，而在生产代码中会自动删除这些检查。

Java引入了关键字assert，这个关键字有两种形式：
- assert condition
- assert condition:expression

这两个语句都会计算条件，如果结果为false,则抛出一个异常。

默认情况下，断言是禁用的。可以通过参数启用

看书302页，介绍了使用断言完成参数检查和提供假设文档。
#### 日志
大概看下书就行，从305页起。不看也行
#### 调试技巧
书321页
### 泛型程序设计
#### 为什么要使用泛型程序设计
泛型程序设计意味着编写的代码可以对多种不同类型的对象重用。例如，你不希望为手机String和File对象分别编写不同的类。ArrayList类就可以手机任何类的对象，这就是泛型设计的一个例子。
##### 类型参数的好处
在Java中增加泛型类之前，泛型程序设计是用*继承*实现的。ArrayList类只维护一个Object引用的数组。这种方法存在两个问题，当获取一个值时必须进行强制类型转换，也没有错误检查，可以向数组添加任何类的值

泛型提供了一个更好的解决方案：类型参数。ArrayList类中有一个参数类型来指示元素的类型，new ArrayList<String>();

如果用一个明确的类型，则可以使用"菱形"语法省略构造器中的类型参数，如ArrayList<String> files = new ArrayList<>();

编译器可以充分利用这个类型信息，让你的程序更安全，也更易读、
#### 定义简单泛型类
看书328页
#### 泛型方法
- 泛型类可以在普通方法中定义，也可以在泛型类中定义
- 泛型变量放在修饰符(public static)的后面，并在返回类型的前面
- 当调用一个泛型方法时，可以把具体类型包围在尖括号中，放在方法前面，如object.<T>method(...)。也可以简单地调用，即省略具体泛型。
#### 类型变量的限定
- 有时，类或方法需要对类型变量加以约束，如限制类型T实现了Comparable接口。
- 可以通过对类型变量T设置一个限定(bound)来实现这一点，public static \<T extends Comparable> T method(T a)...;
- \<T extends BoundType> 表示T是限定类型(BoundType)的子类型，T和限定类型可以是类，也可以是接口
- 一个类型变量或通配符可以有多个限定，如T extends Comparable & Serializable
- 限定类型用"&"分隔，而逗号用来分隔类型变量。最多有一个限定是类，并且他必须是限定列表的第一个限定。
#### 类型擦除
- 无论何时定义一个泛型类型，都会自动提供一个原始类型。这个原始类型的名字就是去掉类型参数后的泛型类型名。类型变量会被擦除，并替换为其限定类型，对于无限定的变量替换为Object.
- 类型擦除后，编译器自动插入强制类型转换。
- 书335页转换泛型方法6

总之，对于Java泛型的转换，需要记住一下几个事实
- 虚拟机中没有泛型，只有普通的类和方法
- 所有的类型参数都会替换为他们的限定类型
- 会合成桥方法来保持多态
- 为保持类型安全性，必要时会插入强制类型转换

#### 限制与局限性
- 不能使用基本类型代替类型参数。没有\<double>，只有\<Double>
- 所有的类型查询只产生原始类型。如果试图查询一个对象是否属于某个泛型类型，会得到一个编译器错误或返回原始类型。
- 不能实例化参数化类型的数组，如var table = new Pair<String>[10];
- 不能实例化类型变量，如new T(...)
- 不能构造泛型数组
- 不能使用带有类型变量的静态字段和方法
- 不能抛出或捕获泛型类的实例
- Java异常要求必须为所有检查型异常提供一个处理器，不过可以利用泛型取消这个机制
#### 泛型类型的继承规则
虽然Employee是Manager的父类，但Pair<Employee>不是Pair<Manager>的父类，此外，ArrayList<Manager>可以转换为一个List<Manager>，不可以转换为List<Employee>
#### 通配符类型
##### 概念
- 在通配符类型中，允许类型参数发生变化。例如，Pair<? extends Employee>表示任何泛型Pair类型，它的类型参数是Employee的子类。
- 类型Pair<Manager>是Pair<? extends Employee>的子类型
##### 通配符的超类型限定
- ? super Manager表示这个通配符限定为Manager的所有父类。

#### 反射和泛型
没看，==
### 集合



